<html>
    <head>
        <title>WebWork - 
        SiteMesh
         </title>
	    <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
	    <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
		    <tr>
			    <td valign="top" class="pagebody">
				    <p>SiteMesh can be found at <a href="http://www.opensymphony.com/sitemesh" title="Visit page outside Confluence">&#104;ttp://www.opensymphony.com/sitemesh</a></p>

<p>Integrating WebWork with SiteMesh is amazingly simple: you don't have to do anything in fact. WebWork stores all its value stack information in the request attributes, meaning that if you wish to display data that is in the stack (or even the ActionContext) you can do so by using the normal tag libraries that come with WebWork. That's it!</p>

<h3><a name="SiteMesh-Passingdataaround">Passing data around</a></h3>

<p>One thing to note is when you want to pass a value from a decorated page to a decorator using the <b>&lt;ww:set&gt;</b> tag, you need to specify a scope (request, session, application) if the decorated page is invoked directly (not a result of an action).  By default if no action has been executed and no scope was specified, the set value will only availlable from the same PageContext.</p>

<h3><a name="SiteMesh-Localization">Localization</a></h3>

<p>In WebWork 2.1.7, support was added that makes using i18n in decorators much easier. Now using the &lt;ww:text/&gt; tag works seemlessly. In the rare event where you need to reference an i18n string, use the id attribute as documented in the <a href="Text tag.html" title="Text tag">Text tag</a>.</p>

<p>An example of such situation is given below. Typically embedding i18n in to form elements would be done using the following:</p>

<div class="code"><div class="codeContent">
<pre class="code-xml"><span class="code-tag">&lt;ww:textfield label=<span class="code-quote">"getText('com.acme.login.text')"</span> name=<span class="code-quote">"'login'"</span>/&gt;</span></pre>
</div></div>

<p>However, due to the way WebWork and SiteMesh work, you would need to seperate the above code in to two tags.</p>

<div class="code"><div class="codeContent">
<pre class="code-xml"><span class="code-tag">&lt;ww:text id=<span class="code-quote">"login"</span> name=<span class="code-quote">"'com.acme.login.text'"</span>/&gt;</span>
<span class="code-tag">&lt;ww:textfield label=<span class="code-quote">"#login"</span> name=<span class="code-quote">"'login'"</span>/&gt;</span></pre>
</div></div>


<h3><a name="SiteMesh-SiteMesh%2CVelocity%2CandWebWork">SiteMesh, Velocity, and WebWork</a></h3>

<p>If you are using Velocity for your SiteMesh decorators, we recommend not using the WebWorkVelocityServlet or the SiteMeshVelocityServlet. In fact, we don't recommend you use any servlet at all. Instead, try creating a servlet that extends PageFilter and then using that servlet in place of PageFilter in web.xml. In your cusotm servlet, override the applyDecorator() method and then use WebWork's VelocityManager to access your decorator templates. You can use VelocityManager to create a default Context as well, which will include all the WebWork variables such as $stack. Then simply add the Page object to the context and then you can access the page parts using $page.title, $page.body, etc.</p>

                    			    </td>
		    </tr>
	    </table>
    </body>
</html>
