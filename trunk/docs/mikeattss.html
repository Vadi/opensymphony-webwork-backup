<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en_US" xml:lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>OpenSymphony Wiki (Offline Version) :: WebWork2 Documentation</title>
  <link type="text/css" href="main.css" rel="STYLESHEET"/>
</head>
<body>
  <div id="page-logo">
    <a href="index.html">WebWork2 Documentation</a>
  </div>
    <div class="snip-title">
	  <h1 class="snip-name">Writeup of Mike&#039;s Talk at TSS on WebWork2
  
  </h1>
  </div>
<div id="snip-content" class="snip-content">

 <div class="snip-attachments"></div>
 
 WebWork2 : “Strutting the OpenSymphony way” – Mike Cannon-Brookes<p class="paragraph"/><a href="index.html">WebWork2</a> is a pull-based MVC framework focused on componentization and code reuse. It is currently in beta, but is being used by several opensource projects and a few commercial projects in development. This is the second generation of WebWork, which was originally developed by Rickard Oberg, and in this release, what was <a href="http://wiki.opensymphony.com/space/WebWork">WebWork</a> has been broken into two projects, <a href="http://wiki.opensymphony.com/space/XWork">XWork</a> and <a href="index.html">WebWork2</a>.<p class="paragraph"/>Xwork is a generic command pattern implementation with absolutely NO ties to the web. Xwork provides many core services, including interceptors, meta-data based validation, type conversion, a very powerful expression language (OGNL – the Object Graph Notation Language) and an Inversion of Control (IoC) container implementation.<p class="paragraph"/>WebWork2 provides a layer on top of XWork to do HTTP request / response handling. It includes a ServletDispatcher to turn HTTP requests into calls to an Action, session and application scope mapping, request parameter mapping, view integration with various web view technologies (JSP, Velocity, FreeMarker, JasperReports), and user interface components in the form of JSP tags and Velocity macros wrapped around reusable UI components.<p class="paragraph"/>An Action is the basic unit of work in WebWork2. It is a simple command object that implements the Action Interface, which has only one method: execute(). Action implementers can extend the ActionSupport class, which provides i18n localization of messages (with one ResourceBundle per Action class and searching up the inheritance tree) and error message handling including class level and field level messages.<p class="paragraph"/>Actions can be developed in one of two styles: Model driven or field driven. Model driven Actions expose a model class via a get method, and the form fields refer directly to the model properties using expressions like “pet.name”. Xwork uses Ognl (the Object Graph Notation Language) as its expression language, and when rendering the page, this expression will translate to getPet().getName(). When setting properties, this will translate to getPet().setName(). This style of development allows for a great deal of model reuse and can allow you to directly edit your domain objects in your web pages, rather than needing a translation layer to form beans. Field driven Actions have their own properties which are used in the view. The action’s execute() method collates the properties and interacts with the model. This can be very useful when your form and model are not parallel. Even in this case, the powerful expression language in WebWork can allow you to compose your form fields into aggregate beans, such as an address bean, which you can reuse to simplify your action classes.<p class="paragraph"/>WebWork2 allows you to build your own reusable UI components by simply defining a Velocity template. This is how the pre-built components of WebWork2 are built for common components such as text fields, buttons, forms, etc. and made available from any view type (either JSP or Velocity at the moment). These components are skinnable by defining multiple templates for the same component in different paths. If your components include the default header and footer templates that are used in the pre-built templates, then they will inherit the ability to automatically handle displaying error messages beside the problem form field. These custom UI components are especially handy for reusing templates which handle your custom model types or for things like date pickers, which Mike showed as an example.<p class="paragraph"/>Interceptors in Xwork allow common code to be applied around (before and/or after) action execution. This is what Mike calls “Practical AOP”. Interceptors help to decouple and componentized your code. Interceptors can be organized into stacks, which are lists of interceptors to be applied in sequence, and can be applied to actions or whole packages. Much of the core functionality of Xwork and WebWork2 is implemented as Interceptors. The common basic examples of Interceptors are timing and logging, and these are built in with Xwork. Mike went through an example of an interceptor to identify users of events via email. This interceptor has its own external configuration file which specifies which users are interested in which events, and it compares this configuration with the action invocations passing through it to determine if any messages should be sent.<p class="paragraph"/>Xwork’s validation framework allows for decoupled validation of action properties. It is implemented as an Interceptor and reads external XML files which define the validations to be applied to the Action. Error messages are loaded from the Action’s localized messages and flow through to the UI. Validator classes can be plugged in to add to the set of bundled validators. The bundled validators include required field and required String validators, range validators for Dates and numbers, and email and URL validators. Xwork also includes expression validators at both the Action and field level which allow you to use any Ognl expression as the validation.<p class="paragraph"/>Inversion of Control (IoC) removes the burden of managing components from your code and puts it on the container. The container takes care of managing component lifecycle and dependencies. EJB is an example of IoC, but with limited services. IoC promotes simplicity and decoupling of your components and encourages your classes to be smaller and more focused. Unit testing is also simplified, as you can just supply MockObject instances of the services your code depends upon during testing. Xwork and WebWork2 provide a web-native IoC container which manages component dependencies. In WebWork2 IoC is implemented as lifecycle managers (SessionLifecycleListener, etc) and an Interceptor. There are 4 component scopes in WebWork2 IoC: Application, HTTP Session, HTTP Request, and Action invocation. IoC in Xwork / WebWork2 is purely optional, so you can use it if you want it.<p class="paragraph"/>Xwork / WebWork2 allows for sets of Actions and their views to be bundled as a jar file and reused. Your main xwork.xml file can include the xml configuration file of the jar file because they are included from the classpath. Similarly, if your views are <span class="nobr"><img src="http://wiki.opensymphony.com/images/external-link.png" alt="&gt;&gt;" border="0"/><a href="http://jakarta.apache.org/velocity/index.html">Velocity</a></span> templates, you can bundle your views in the jar file and they will be loaded from the classpath when rendering. This allows for componentization of your application and reuse of bundled Actions across applications. 
<i class="italic">I have to admit, when Mike mentioned this feature, I thought he was crazy. I didn’t say anything at the session, but asked him about it later, and he said “didn’t you write the package include stuff?” I’ll take it as a good sign that things can be used in a different way than was imagined. :-)</i><p class="paragraph"/>Mike finished up with a comparison of WebWork2 vs. <span class="nobr"><img src="http://wiki.opensymphony.com/images/external-link.png" alt="&gt;&gt;" border="0"/><a href="http://jakarta.apache.org/struts/index.html">Struts</a></span> . Struts is obviously the 500 lb gorilla in the web MVC space, so why use WebWork? WebWork’s pros include being a smaller, simpler framework, not having to build ActionForm beans, making it very simple to test your Actions, having multiple well-supported view technologies, simpler views with less JSP tags and a more powerful expression language, not having to make your Actions thread-safe, not having your Actions tied to the web, and not being part of <span class="nobr"><img src="http://wiki.opensymphony.com/images/external-link.png" alt="&gt;&gt;" border="0"/><a href="http://jakarta.apache.org">Jakarta</a></span> . WebWork2 also adds many new features such as Interceptors, packages, IoC, etc. WebWork’s cons include being a smaller project with fewer books and less tool support, having less standards support for specs like JSTL and JSF, and not being part of <span class="nobr"><img src="http://wiki.opensymphony.com/images/external-link.png" alt="&gt;&gt;" border="0"/><a href="http://jakarta.apache.org">Jakarta</a></span> .<p class="paragraph"/>For more information, check out:
<ul class="star">
<li><span class="nobr"><img src="http://wiki.opensymphony.com/images/external-link.png" alt="&gt;&gt;" border="0"/><a href="http://www.opensymphony.com">&#104;ttp://www.opensymphony.com</a></span> for website, mailing list, CVS etc</li>
<li><span class="nobr"><img src="http://wiki.opensymphony.com/images/external-link.png" alt="&gt;&gt;" border="0"/><a href="http://wiki.opensymphony.com">&#104;ttp://wiki.opensymphony.com</a></span> for WW2/XW documentation</li>
<li><span class="nobr"><img src="http://wiki.opensymphony.com/images/external-link.png" alt="&gt;&gt;" border="0"/><a href="http://blogs.atlassian.com/rebelutionary/archives/000200.html">&#104;ttp://blogs.atlassian.com/rebelutionary/archives/000200.html</a></span> for Mike's presentations in Powerpoint</li>
</ul><p class="paragraph"/>

  </div>
</body>
</html>
